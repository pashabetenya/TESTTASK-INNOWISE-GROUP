// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AppException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppExceptionCopyWith<$Res> {
  factory $AppExceptionCopyWith(
          AppException value, $Res Function(AppException) then) =
      _$AppExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class _$AppExceptionCopyWithImpl<$Res> implements $AppExceptionCopyWith<$Res> {
  _$AppExceptionCopyWithImpl(this._value, this._then);

  final AppException _value;
  // ignore: unused_field
  final $Res Function(AppException) _then;
}

/// @nodoc
abstract class _$$NoRecordsExceptionCopyWith<$Res> {
  factory _$$NoRecordsExceptionCopyWith(_$NoRecordsException value,
          $Res Function(_$NoRecordsException) then) =
      __$$NoRecordsExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoRecordsExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$NoRecordsExceptionCopyWith<$Res> {
  __$$NoRecordsExceptionCopyWithImpl(
      _$NoRecordsException _value, $Res Function(_$NoRecordsException) _then)
      : super(_value, (v) => _then(v as _$NoRecordsException));

  @override
  _$NoRecordsException get _value => super._value as _$NoRecordsException;
}

/// @nodoc

class _$NoRecordsException implements NoRecordsException {
  _$NoRecordsException();

  @override
  String toString() {
    return 'AppException.noRecords()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoRecordsException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return noRecords();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return noRecords?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (noRecords != null) {
      return noRecords();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return noRecords(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return noRecords?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (noRecords != null) {
      return noRecords(this);
    }
    return orElse();
  }
}

abstract class NoRecordsException implements AppException {
  factory NoRecordsException() = _$NoRecordsException;
}

/// @nodoc
abstract class _$$EmptyExceptionCopyWith<$Res> {
  factory _$$EmptyExceptionCopyWith(
          _$EmptyException value, $Res Function(_$EmptyException) then) =
      __$$EmptyExceptionCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class __$$EmptyExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$EmptyExceptionCopyWith<$Res> {
  __$$EmptyExceptionCopyWithImpl(
      _$EmptyException _value, $Res Function(_$EmptyException) _then)
      : super(_value, (v) => _then(v as _$EmptyException));

  @override
  _$EmptyException get _value => super._value as _$EmptyException;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$EmptyException(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EmptyException implements EmptyException {
  _$EmptyException(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'AppException.empty(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmptyException &&
            const DeepCollectionEquality().equals(other.message, message));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(message));

  @JsonKey(ignore: true)
  @override
  _$$EmptyExceptionCopyWith<_$EmptyException> get copyWith =>
      __$$EmptyExceptionCopyWithImpl<_$EmptyException>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return empty(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return empty?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EmptyException implements AppException {
  factory EmptyException(final String message) = _$EmptyException;

  String get message;
  @JsonKey(ignore: true)
  _$$EmptyExceptionCopyWith<_$EmptyException> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FailedToParseExceptionCopyWith<$Res> {
  factory _$$FailedToParseExceptionCopyWith(_$FailedToParseException value,
          $Res Function(_$FailedToParseException) then) =
      __$$FailedToParseExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FailedToParseExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$FailedToParseExceptionCopyWith<$Res> {
  __$$FailedToParseExceptionCopyWithImpl(_$FailedToParseException _value,
      $Res Function(_$FailedToParseException) _then)
      : super(_value, (v) => _then(v as _$FailedToParseException));

  @override
  _$FailedToParseException get _value =>
      super._value as _$FailedToParseException;
}

/// @nodoc

class _$FailedToParseException implements FailedToParseException {
  _$FailedToParseException();

  @override
  String toString() {
    return 'AppException.failedToParse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FailedToParseException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return failedToParse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return failedToParse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (failedToParse != null) {
      return failedToParse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return failedToParse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return failedToParse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (failedToParse != null) {
      return failedToParse(this);
    }
    return orElse();
  }
}

abstract class FailedToParseException implements AppException {
  factory FailedToParseException() = _$FailedToParseException;
}

/// @nodoc
abstract class _$$NullObjectExceptionCopyWith<$Res> {
  factory _$$NullObjectExceptionCopyWith(_$NullObjectException value,
          $Res Function(_$NullObjectException) then) =
      __$$NullObjectExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NullObjectExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$NullObjectExceptionCopyWith<$Res> {
  __$$NullObjectExceptionCopyWithImpl(
      _$NullObjectException _value, $Res Function(_$NullObjectException) _then)
      : super(_value, (v) => _then(v as _$NullObjectException));

  @override
  _$NullObjectException get _value => super._value as _$NullObjectException;
}

/// @nodoc

class _$NullObjectException implements NullObjectException {
  _$NullObjectException();

  @override
  String toString() {
    return 'AppException.nullObject()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NullObjectException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return nullObject();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return nullObject?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (nullObject != null) {
      return nullObject();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return nullObject(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return nullObject?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (nullObject != null) {
      return nullObject(this);
    }
    return orElse();
  }
}

abstract class NullObjectException implements AppException {
  factory NullObjectException() = _$NullObjectException;
}

/// @nodoc
abstract class _$$noUniquenessExceptionCopyWith<$Res> {
  factory _$$noUniquenessExceptionCopyWith(_$noUniquenessException value,
          $Res Function(_$noUniquenessException) then) =
      __$$noUniquenessExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$noUniquenessExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$noUniquenessExceptionCopyWith<$Res> {
  __$$noUniquenessExceptionCopyWithImpl(_$noUniquenessException _value,
      $Res Function(_$noUniquenessException) _then)
      : super(_value, (v) => _then(v as _$noUniquenessException));

  @override
  _$noUniquenessException get _value => super._value as _$noUniquenessException;
}

/// @nodoc

class _$noUniquenessException implements noUniquenessException {
  _$noUniquenessException();

  @override
  String toString() {
    return 'AppException.noUniqueness()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$noUniquenessException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return noUniqueness();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return noUniqueness?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (noUniqueness != null) {
      return noUniqueness();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return noUniqueness(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return noUniqueness?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (noUniqueness != null) {
      return noUniqueness(this);
    }
    return orElse();
  }
}

abstract class noUniquenessException implements AppException {
  factory noUniquenessException() = _$noUniquenessException;
}

/// @nodoc
abstract class _$$NoExistExceptionCopyWith<$Res> {
  factory _$$NoExistExceptionCopyWith(
          _$NoExistException value, $Res Function(_$NoExistException) then) =
      __$$NoExistExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoExistExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$NoExistExceptionCopyWith<$Res> {
  __$$NoExistExceptionCopyWithImpl(
      _$NoExistException _value, $Res Function(_$NoExistException) _then)
      : super(_value, (v) => _then(v as _$NoExistException));

  @override
  _$NoExistException get _value => super._value as _$NoExistException;
}

/// @nodoc

class _$NoExistException implements NoExistException {
  _$NoExistException();

  @override
  String toString() {
    return 'AppException.noExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoExistException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return noExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return noExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (noExist != null) {
      return noExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return noExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return noExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (noExist != null) {
      return noExist(this);
    }
    return orElse();
  }
}

abstract class NoExistException implements AppException {
  factory NoExistException() = _$NoExistException;
}

/// @nodoc
abstract class _$$ServerExceptionCopyWith<$Res> {
  factory _$$ServerExceptionCopyWith(
          _$ServerException value, $Res Function(_$ServerException) then) =
      __$$ServerExceptionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServerExceptionCopyWithImpl<$Res>
    extends _$AppExceptionCopyWithImpl<$Res>
    implements _$$ServerExceptionCopyWith<$Res> {
  __$$ServerExceptionCopyWithImpl(
      _$ServerException _value, $Res Function(_$ServerException) _then)
      : super(_value, (v) => _then(v as _$ServerException));

  @override
  _$ServerException get _value => super._value as _$ServerException;
}

/// @nodoc

class _$ServerException implements ServerException {
  _$ServerException();

  @override
  String toString() {
    return 'AppException.server()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServerException);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noRecords,
    required TResult Function(String message) empty,
    required TResult Function() failedToParse,
    required TResult Function() nullObject,
    required TResult Function() noUniqueness,
    required TResult Function() noExist,
    required TResult Function() server,
  }) {
    return server();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
  }) {
    return server?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noRecords,
    TResult Function(String message)? empty,
    TResult Function()? failedToParse,
    TResult Function()? nullObject,
    TResult Function()? noUniqueness,
    TResult Function()? noExist,
    TResult Function()? server,
    required TResult orElse(),
  }) {
    if (server != null) {
      return server();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoRecordsException value) noRecords,
    required TResult Function(EmptyException value) empty,
    required TResult Function(FailedToParseException value) failedToParse,
    required TResult Function(NullObjectException value) nullObject,
    required TResult Function(noUniquenessException value) noUniqueness,
    required TResult Function(NoExistException value) noExist,
    required TResult Function(ServerException value) server,
  }) {
    return server(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
  }) {
    return server?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoRecordsException value)? noRecords,
    TResult Function(EmptyException value)? empty,
    TResult Function(FailedToParseException value)? failedToParse,
    TResult Function(NullObjectException value)? nullObject,
    TResult Function(noUniquenessException value)? noUniqueness,
    TResult Function(NoExistException value)? noExist,
    TResult Function(ServerException value)? server,
    required TResult orElse(),
  }) {
    if (server != null) {
      return server(this);
    }
    return orElse();
  }
}

abstract class ServerException implements AppException {
  factory ServerException() = _$ServerException;
}
